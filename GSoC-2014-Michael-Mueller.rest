==================================================
Reimplementation of sunpy.wcs as sunpy.coordinates
==================================================

Background
----------
I am a current high school senior, and my academic interests lie primarily in math, physics, and programming. Mathematics has always excited me as a subject, and I have taken online classes in multivariable calculus and differential equations with a local community college, as well as linear algebra with Oklahoma State University, after exhausting my high school's curriculum. More recently, I have become interested in physics because it so heavily relies on the application of mathematical deduction to observation, and I enjoy learning about how mathematics applies to the natural world. In addition to programming, I enjoy running, reading, and playing or listening to music in my spare time.

Programming Information
-----------------------
I run Ubuntu Linux on my laptop, and my preferred editors generally vary by language. For standard text editing and programming in C++, I use emacs. However, I use Eclipse for Java projects and will use either emacs or IDLE when programming in Python. Although emacs has a bit of a learning curve, I find it very useful as an editor because its numerous commands and macros allow for faster and more powerful editing. I also often use IDLE simply because I’ve been using it longer than emacs and I like its syntax highlighting and interactive shell.

My programming background extends back to 7th grade, when I discovered MIT’s educational programming tool Scratch. After playing around with Scratch and reading more about programming, I used online tutorials to teach myself Java. From making small computer games with friends to trying out programming challenges like Project Euler and Code Golf, I then continued to immerse myself in the world of programming and soon picked up experience with C++ and Python. Since then, I have continued to enjoy programming recreationally. 			Although I haven’t often worked on large programming projects, one project I particularly enjoyed working on was the creation of an OpenGL-based 3D engine in C++. This project was exciting to work on because it involved learning about graphics programming, which contains interesting mathematical underpinnings (such as matrix transformations and quaternions). I also incorporated simple models of mathematical and physical phenomena in the engine, such as Lindenmayer systems (or L-systems), which allow for the rendering of fractal patterns which imitate such natural objects as plants, and particle systems, which can be used to create interesting effects like fireworks or the flow of a water fountain. Although I didn’t implement very advanced versions of these effects, I enjoyed discovering new intersections between math, physics, and programming. These intricate relationships continue to excite me, and I hope to explore the applications of computer science to other fields in the future.

I have been using Python in particular for about three years, and I find it very useful as a language whenever high-level programming is appropriate. Although there is somewhat of a performance hit in using Python compared to more mid-level languages like C or C++, its ease of use and natural syntax have allowed me to program more quickly and with less propensity for error. I particularly enjoy the most distinctive, or “Pythonic”, aspects of Python, such as list comprehensions, generators, and lambda expressions. In fact, I’ve often found that when I return to C++ or Java after using Python for a while, I become annoyed at having to translate one of these features into a more cumbersome syntax. In my opinion, Python’s most useful language feature is the existence of iterables and functions relating to them. ``for i, elem in enumerate(elem_set): foo(elem, i)`` is far clearer and easier to use than the C++ equivalent ``for (std::set<int>::iterator it = elem_set.begin(); it != elem_set.end(); ++it) { foo(*it, it - elem_set.begin()); }``, and standard library functions like map() and zip() make it much simpler to operate on elements of a container.

I am reasonably comfortable with git, having previously contributed to a friend’s project on BitBucket and having begun contributing to Sunpy on GitHub. As of this writing, I have four merged pull requests for Sunpy (https://github.com/sunpy/sunpy/pull/854, https://github.com/sunpy/sunpy/pull/859, https://github.com/sunpy/sunpy/pull/861, http://github.com/sunpy/sunpy/pull/877) as well as two currently unmerged pull requests (https://github.com/sunpy/sunpy/pull/883 and https://github.com/sunpy/sunpy/pull/901). These have mostly involved documentation and renaming, but #859 involved adding tests for each public function in the previously untested module ``util.util``.

I have also become involved with Astropy, and the prospect of working with both Sunpy and Astropy simultaneously is part of the reason why this project interests me. I currently have three merged pull requests for minor issues (http://github.com/astropy/astropy/pull/2110, https://github.com/astropy/astropy/pull/2114, and https://github.com/astropy/astropy/pull/2142). These pull requests have involved adding documentation for time formats supported by Astropy, removing exceptions from comparison operators in the Time class, and documenting classes in ``astropy.io.ascii.core``. I have also been working on a more significant open pull request implementing an HTML reader and writer in ``astropy.io.ascii``, which may be viewed at https://github.com/astropy/astropy/pull/2160.

Project Details
---------------
Abstract
~~~~~~~~
Since the Sunpy library is intended for use by solar physicists and is therefore highly scientific in nature, a powerful framework for describing the position of points in 3-dimensional space is highly important. `Thompson, W. (2009) <http://adsabs.harvard.edu/abs/2006A%26A...449..791T>`_ describes a number of solar coordinate systems which are particularly convenient for use in solar physics. These systems range between Cartesian, Cylindrical, and Spherical representations and are each applicable in a variety of situations, varying based on the importance of the observer’s position, whether angles or distances are most appropriate, etc. Currently, Sunpy contains a number of functions in ``sunpy.wcs.wcs``, such as ``convert_hpc_hcc`` and ``convert_hcc_hg``, for switching between various solar coordinate systems. However, this system is less than ideal as it simply uses ``numpy.ndarray`` for coordinate data and therefore misses out on useful coordinate functionality.

The project Astropy (closely related to the Sunpy project) contains a useful coordinate package in ``astropy.coordinates``. However, as part of `APE5 <https://github.com/astropy/astropy-APEs/pull/6>`_ (Astropy Proposal for Enhancement #5), Astropy will be switching to a new coordinate framework involving the classes CoordinateFrame and CoordinateRepresentation, which allows for the more efficient creation of new reference systems and fixes previous issues with the ``astropy.coordinates`` package. It would be extremely helpful to be able to use this framework in the Sunpy library.

Accordingly, my proposal is to use Astropy's new coordinate framework to implement Heliographic, Helio-Centric, and Helio-Projective coordinates using the new inheritance model spelled out in APE5. In this model, high-level classes such as ``SphericalRepresentation`` and ``CartesianRepresentation`` inherit from ``CoordinateRepresentation`` and store actual spatial information, while lower-level classes combining both reference systems and frames inherit from ``CoordinateFrame``. I intend to create subclasses from ``CoordinateFrame`` for these Heliographic, Helio-Centric, and Helio-Projective coordinate reference systems and add functionality for such reference frames as Heliocentric Aries Ecliptic, Heliocentric Earth Equatorial, and more.

At this point, my primary concern will be with the integration between these newly implemented reference systems and the future Astropy coordinate package, as well as the redesign of current functionality in ``sunpy.wcs``. This will involve implementing transformations between solar reference systems and the Cartesian, Cylindrical, and Spherical coordinate representations, as well as adding general functionality for converting between Heliographic, Helio-Centric, and Helio-Projective coordinates. In addition, I will work on the general task of integrating the Astropy coordinate framework into the existing Sunpy data types, such as ``Map`` and ``LightCurve``.

Finally, I plan to take even further advantage of the new Astropy coordinate system by implementing transformations between the celestial coordinate systems of Astropy and the solar coordinate systems I have implemented as part of this project. If there is enough time left over, I also hope to work on the general task of integrating the ``astropy.units`` package, which provides a powerful framework for handling the units of physical quantities, into Sunpy.

Detailed Description
~~~~~~~~~~~~~~~~~~~~
:Community bonding period (April 21 — May 18):

 Read in detail about solar and other celestial coordinate systems to gain a solid understanding of these systems and of the algorithms for converting between them. Become more familiar with both Sunpy and Astropy, reading documentation (particularly regarding the changes accompanying APE5) and trying to fix issues on GitHub.

:May 19 — June 1 (2 weeks):
 Begin writing classes ``HelioProjective``, ``HelioGraphic``, and ``HelioCentric`` extending ``CoordinateFrame``, using the new Astropy inheritance framework as a guide. Use extensive testing to ensure that this implementation works as intended. Start implementing specific reference frames for these systems after discussing with my project mentor which frames will be of particular use.

:June 2 — June 8 (1 week):
 Finish the implementation of classes ``HelioProjective``, ``HelioGraphic``, and ``HelioCentric`` and fix any issues or bugs that arise that this point. Once this is done, implement transformations between coordinate representations, such as ``SphericalRepresentation``, ``CartesianRepresentation``, etc.

:June 9 — June 22 (2 weeks):
 During these two weeks I will focus on extending the functionality of my new implementation. Use the bi-directional transformation graph in ``astropy.coordinates`` to implement conversion between Heliographic, Helio-Projective and Helio-Centric coordinates, replacing the current functions in ``sunpy.wcs``.

:June 23 — June 29 (1 week):
 Mid-term evaluations take place during this week. Since the project should be at least halfway completed, use this week to write up extensive documentation for the current functionality, write tests I might have missed in previous weeks, and work on any potential patches that might be submitted to the Astropy code base involving the coordinates package.

:June 30 — July 6 (1 week):
 Explore the Astropy codebase in order to determine how conversion between existing celestial coordinate systems and the newly implemented solar coordinate systems might work. This part will involve reading more about mathematical conversions between coordinate systems and other nuances similar to the use of the small-angle approximation in converting heliocentric to helioprojective coordinates. Write complete documentation for these conversions and formulate a plan for implementing them.

:July 7 — July 13 (1 week):
 Work on the implementation spelled out in the previous week, starting with the most common celestial coordinate systems like ICRS (International Celestial Reference System) and Galactic. Depending on the nature of the API accompanying APE5, the difficulty of this implementation might vary considerably.

:July 14 — July 20 (1 week):
 Thoroughly test the previous week’s implementation and add support for conversion involving other celestial coordinate systems. Work with the Astropy library (which might involve submitting patches upstream) in order to facilitate all of these conversions. Make certain that all conversions are well documented.

:July 21 — July 27 (1 week):
 After performing unit testing and fixing any unforeseen issues that may arise, work on integrating the new coordinate framework into existing Sunpy data types like ``Map`` and ``LightCurve``. Carefully document the changes that will be imposed by adding this new coordinate functionality.

:July 28 — August 10 (2 weeks):
 These two weeks will serve as a buffer period in case earlier steps of the proposal require more time, unforeseen difficulties arise, etc. If everything runs smoothly and the buffer period is unnecessary, then work on integrating ``astropy.units`` into Sunpy. This will allow the Sunpy library to make use of functionality like unit conversion, decomposing units into irreducible parts, and dynamically creating new units which seamlessly fit into the existing  ``astropy.units`` framework. There are also other opportunities I might be able to take on relating to this task, such as the integration of the highly important Astropy class ``Quantity`` into the Sunpy code base.

:August 11 (suggested pencils down date) — August 22 (final evaluation deadline):
 Write documentation for all previous code and add any tests I may have missed during the main coding period. Look for potential bugs and fix any that arise.

Additional Information
----------------------
The last day of classes for me will be May 27 (the beginning of the second week of coding), so I will not be able to devote 40 hours for the first week. However, I anticipate that I will have very little, if any, schoolwork and I should be able to complete the set tasks for week 1. If not, then I can make up for missed work the next couple of weeks. Except for the first week, I will be fully capable of spending 40 hours per week on Google Summer of Code.

I have set up a blog for Google Summer of Code (http://muellergsoc.blogspot.com), which I intend to use weekly during the summer for progress reports. I will also be available for regular contact with my project mentor over the course of the summer through IRC, email, phone calls, or any other mutually convenient form of communication.

Note: all times in this proposal are EST (GMT-5).